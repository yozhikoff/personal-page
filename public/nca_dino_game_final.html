<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NCA Dino Game - Final Release</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        .container {
            text-align: center;
            position: relative;
        }

        .game-wrapper {
            position: relative;
            border: 3px solid #333;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            background: white;
        }

        canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
        }

        .controls button {
            margin: 5px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #333;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s;
        }

        .controls button:hover {
            background: rgba(255, 255, 255, 1);
            transform: translateY(-1px);
        }

        .score-display {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #333;
            font-weight: bold;
            font-size: 18px;
            background: rgba(255, 255, 255, 0.9);
            padding: 5px 10px;
            border-radius: 6px;
            z-index: 1000;
        }

        .game-title {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #333;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(255, 255, 255, 0.8);
            z-index: 1001;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px 25px;
            border-radius: 12px;
            border: 2px solid #333;
            transition: all 0.3s ease;
        }

        .game-title.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        .info {
            margin-top: 20px;
            color: #fff;
            font-size: 14px;
        }

        .loading {
            color: #fff;
            font-size: 18px;
            margin-bottom: 20px;
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="loading" id="loadingText">Loading NCA Dino Game...</div>
        
        <div class="game-wrapper hidden" id="gameWrapper">
            <div class="controls">
                <button id="startBtn">üéÆ Start Game</button>
                <button id="debugBtn">üêõ Show Debug Boxes</button>
            </div>
            
            <div class="score-display hidden" id="scoreDisplay">00000</div>
            
            <div class="game-title hidden" id="gameTitle">Dino in NCA-land</div>
            
            <canvas id="gameCanvas" width="768" height="384"></canvas>
            <canvas id="overlayCanvas" width="768" height="384" style="position: absolute; top: 0; left: 0; pointer-events: none;"></canvas>
        </div>

        <div class="info">
            <div>Use SPACEBAR to jump, B to bomb!</div>
            <div>Destroy cacti with bombs to clear your path!</div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
    
    <script>
        class NCADinoGame {
            constructor() {
                // Game state management
                this.gameState = 'LOADING'; // LOADING, INTRO, WAITING, PLAYING, GAME_OVER
                this.gameStartTime = 0;
                this.bombTutorialShown = false;
                
                // Canvas setup
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.overlayCanvas = document.getElementById('overlayCanvas');
                this.overlayCtx = this.overlayCanvas.getContext('2d');
                
                // Game elements
                this.scoreDisplay = document.getElementById('scoreDisplay');
                this.gameTitle = document.getElementById('gameTitle');
                this.startBtn = document.getElementById('startBtn');
                this.debugBtn = document.getElementById('debugBtn');
                
                // NCA parameters
                this.modelWidth = 256;
                this.modelHeight = 32;
                this.pixelScale = 3;
                this.canvasWidth = this.canvas.width;
                this.canvasHeight = this.canvas.height;
                this.gameAreaHeight = 288; // Reduced game area
                this.topSpaceHeight = 96; // White space above game area
                
                // Game state
                this.worldOffset = 0;
                this.scrollSpeed = 1.5; // NCA pixels per frame
                this.windowStartX = 0;
                this.score = 0;
                this.isGameOver = false;
                this.showDebugBoxes = false;
                
                // Generation control
                this.generationEdgePercent = 0.8; // 80% for 256px version
                this.targetGenerationX = Math.floor(this.modelWidth * this.generationEdgePercent);
                this.generationActive = false;
                this.generationComplete = false;
                
                // Dino properties
                this.dinoX = 64; // NCA pixels from left edge
                this.dinoY = 0; // Ground level
                this.dinoVelocityY = 0;
                this.dinoGrounded = true;
                this.dinoJumping = false;
                this.dinoAnimFrame = 0;
                this.dinoAnimSpeed = 8; // Faster animation
                
                // Jump physics (Variable Gravity Per Speed)
                this.targetJumpDistance = 8; // NCA pixels
                this.targetJumpHeight = 8; // NCA pixels
                this.calculateJumpPhysics();
                
                // Terrain and collision
                this.cacti = []; // {x, y, width, height, worldX}
                this.bounds = []; // Collision bounds for debug
                this.destroyedAreas = new Set(); // Track destroyed terrain
                
                // Bomb system
                this.bombs = [];
                this.bombSpeed = 4; // NCA pixels per frame
                this.explosionRadius = 12; // NCA pixels
                
                // Visual elements
                this.clouds = [];
                this.cloudImage = new Image();
                this.cloudImage.src = './dino_assets/Cloud.png';
                
                // Assets
                this.assets = {};
                this.loadAssets();
                
                // Event listeners
                this.setupEventListeners();
                
                // Generation marker
                this.generationMarker = this.createGenerationMarker();
            }
            
            async loadAssets() {
                const assetList = [
                    'DinoStart', 'DinoRun1', 'DinoRun2', 'DinoJump', 'DinoDuck1', 'DinoDuck2', 'DinoDead', 'GameOver'
                ];
                
                const loadPromises = assetList.map(name => {
                    return new Promise((resolve) => {
                        const img = new Image();
                        img.onload = () => {
                            this.assets[name] = img;
                            resolve();
                        };
                        img.src = `./dino_assets/${name}.png`;
                    });
                });
                
                await Promise.all(loadPromises);
                await this.loadModel();
                this.showGame();
            }
            
            async loadModel() {
                try {
                    this.session = await ort.InferenceSession.create('./nca_model_256px.onnx', {
                        executionProviders: ['cpu']
                    });
                    
                    // Initialize terrain
                    this.initializeTerrain();
                } catch (error) {
                    console.error('Failed to load ONNX model:', error);
                }
            }
            
            showGame() {
                document.getElementById('loadingText').classList.add('hidden');
                document.getElementById('gameWrapper').classList.remove('hidden');
                this.gameState = 'INTRO';
            }
            
            initializeTerrain() {
                // Create initial seed terrain
                this.terrain = new Float32Array(this.modelWidth * this.modelHeight * 4);
                
                // Set bottom row to green (RGBA: 0, 1, 0, 1)
                for (let x = 0; x < this.modelWidth; x++) {
                    const idx = ((this.modelHeight - 1) * this.modelWidth + x) * 4;
                    this.terrain[idx] = 0;     // R
                    this.terrain[idx + 1] = 1; // G
                    this.terrain[idx + 2] = 0; // B
                    this.terrain[idx + 3] = 1; // A
                }
                
                this.renderTerrain();
            }
            
            calculateJumpPhysics() {
                // Variable Gravity Per Speed - each speed gets custom gravity for exact targets
                const requiredDurationSeconds = this.targetJumpDistance / (this.scrollSpeed * 60); // 60 FPS
                this.gravity = (8 * this.targetJumpHeight) / (requiredDurationSeconds * requiredDurationSeconds);
                this.jumpVelocity = -Math.sqrt(2 * this.gravity * this.targetJumpHeight);
            }
            
            setupEventListeners() {
                this.startBtn.addEventListener('click', () => this.handleStartButton());
                this.debugBtn.addEventListener('click', () => this.toggleDebugBoxes());
                
                document.addEventListener('keydown', (e) => this.handleKeyPress(e));
                document.addEventListener('keyup', (e) => this.handleKeyRelease(e));
            }
            
            handleStartButton() {
                if (this.gameState === 'INTRO') {
                    this.startIntroSequence();
                }
            }
            
            startIntroSequence() {
                this.gameState = 'INTRO';
                this.generationActive = true;
                this.generationComplete = false;
                this.startBtn.style.display = 'none';
                this.gameTitle.classList.remove('hidden');
                this.gameTitle.textContent = 'Dino in NCA-land';
                
                console.log('üéÆ Starting intro sequence - generation only');
            }
            
            handleKeyPress(e) {
                if (e.code === 'Space') {
                    e.preventDefault();
                    
                    if (this.gameState === 'WAITING') {
                        this.startGameplay();
                    } else if (this.gameState === 'PLAYING' && this.dinoGrounded && !this.dinoJumping) {
                        this.jump();
                    } else if (this.gameState === 'GAME_OVER') {
                        this.restartGame();
                    }
                } else if (e.code === 'KeyB' && this.gameState === 'PLAYING') {
                    this.dropBomb();
                }
            }
            
            handleKeyRelease(e) {
                // Handle key releases if needed
            }
            
            startGameplay() {
                this.gameState = 'PLAYING';
                this.gameStartTime = Date.now();
                this.scoreDisplay.classList.remove('hidden');
                this.gameTitle.textContent = '';
                
                console.log('üéÆ Starting actual gameplay');
            }
            
            jump() {
                if (!this.dinoGrounded || this.dinoJumping) return;
                
                this.dinoJumping = true;
                this.dinoGrounded = false;
                this.dinoVelocityY = this.jumpVelocity;
                
                console.log(`ü¶ï Dino jumping with velocity: ${this.dinoVelocityY.toFixed(2)}`);
            }
            
            dropBomb() {
                const bombX = this.dinoX + 8; // Closer to dino
                const bombY = this.dinoY - 2;
                
                this.bombs.push({
                    x: bombX,
                    y: bombY,
                    velocityY: 0,
                    worldX: this.windowStartX + bombX,
                    active: true
                });
                
                console.log(`üí£ Bomb dropped at NCA(${bombX}, ${bombY}), World(${this.windowStartX + bombX})`);
            }
            
            restartGame() {
                // Reset all game state
                this.worldOffset = 0;
                this.windowStartX = 0;
                this.score = 0;
                this.isGameOver = false;
                this.dinoY = 0;
                this.dinoVelocityY = 0;
                this.dinoGrounded = true;
                this.dinoJumping = false;
                this.gameStartTime = 0;
                this.bombTutorialShown = false;
                
                // Clear game objects
                this.bombs = [];
                this.cacti = [];
                this.bounds = [];
                this.clouds = [];
                this.destroyedAreas.clear();
                
                // Reset terrain
                this.initializeTerrain();
                
                // Start intro sequence again
                this.gameState = 'INTRO';
                this.generationActive = true;
                this.generationComplete = false;
                this.startBtn.style.display = 'block';
                this.scoreDisplay.classList.add('hidden');
                this.gameTitle.classList.remove('hidden');
                this.gameTitle.textContent = 'Dino in NCA-land';
                
                console.log('üîÑ Game restarted');
            }
            
            update() {
                if (this.gameState === 'LOADING') return;
                
                // Handle generation during INTRO state
                if (this.gameState === 'INTRO' && this.generationActive && !this.generationComplete) {
                    this.updateGeneration();
                    
                    // Check if generation reached target
                    const rightmostX = this.findRightmostPixel();
                    if (rightmostX >= this.targetGenerationX) {
                        this.generationComplete = true;
                        this.generationActive = false;
                        this.gameState = 'WAITING';
                        this.gameTitle.textContent = 'Press <space> to jump';
                        console.log('üéÆ Generation complete, waiting for player input');
                    }
                }
                
                // Update game physics during PLAYING state
                if (this.gameState === 'PLAYING') {
                    this.updateScrolling();
                    this.updateDino();
                    this.updateBombs();
                    this.updateClouds();
                    this.updateScore();
                    this.checkCollisions();
                    
                    // Show bomb tutorial after 5 seconds
                    if (!this.bombTutorialShown && Date.now() - this.gameStartTime > 5000) {
                        this.showBombTutorial();
                    }
                }
                
                this.render();
            }
            
            showBombTutorial() {
                this.bombTutorialShown = true;
                this.gameTitle.classList.remove('hidden');
                this.gameTitle.textContent = 'Press <B> for a bomb';
                
                // Hide tutorial after 3 seconds
                setTimeout(() => {
                    this.gameTitle.classList.add('fade-out');
                    setTimeout(() => {
                        this.gameTitle.classList.add('hidden');
                        this.gameTitle.classList.remove('fade-out');
                    }, 300);
                }, 3000);
                
                console.log('üí£ Showing bomb tutorial');
            }
            
            updateScrolling() {
                this.worldOffset += this.scrollSpeed;
                
                // Update sliding window
                const newWindowStartX = Math.floor(this.worldOffset);
                if (newWindowStartX !== this.windowStartX) {
                    this.windowStartX = newWindowStartX;
                    this.extendTerrain();
                }
            }
            
            updateDino() {
                // Animation
                this.dinoAnimFrame++;
                
                // Jump physics
                if (!this.dinoGrounded) {
                    this.dinoVelocityY += this.gravity / 60; // 60 FPS
                    this.dinoY += this.dinoVelocityY / 60;
                    
                    // Check ground collision
                    if (this.dinoY >= 0) {
                        this.dinoY = 0;
                        this.dinoVelocityY = 0;
                        this.dinoGrounded = true;
                        this.dinoJumping = false;
                    }
                }
            }
            
            updateBombs() {
                this.bombs = this.bombs.filter(bomb => {
                    if (!bomb.active) return false;
                    
                    // Apply gravity
                    bomb.velocityY += 0.3;
                    bomb.y += bomb.velocityY;
                    
                    // Check ground collision
                    if (bomb.y >= 0) {
                        this.explodeBomb(bomb);
                        return false;
                    }
                    
                    return true;
                });
            }
            
            explodeBomb(bomb) {
                const centerX = Math.floor(bomb.x);
                const centerY = 0; // Explode at ground level
                
                console.log(`üí• Bomb exploding at NCA(${centerX}, ${centerY})`);
                
                // Create explosion in terrain
                for (let dy = -this.explosionRadius; dy <= this.explosionRadius; dy++) {
                    for (let dx = -this.explosionRadius; dx <= this.explosionRadius; dx++) {
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance <= this.explosionRadius) {
                            const targetX = centerX + dx;
                            const targetY = centerY + dy;
                            
                            if (targetX >= 0 && targetX < this.modelWidth && targetY >= 0 && targetY < this.modelHeight) {
                                const idx = (targetY * this.modelWidth + targetX) * 4;
                                this.terrain[idx] = 0;     // R
                                this.terrain[idx + 1] = 0; // G
                                this.terrain[idx + 2] = 0; // B
                                this.terrain[idx + 3] = 0; // A
                                
                                // Track destroyed area in world coordinates
                                const worldX = this.windowStartX + targetX;
                                this.destroyedAreas.add(`${worldX},${targetY}`);
                            }
                        }
                    }
                }
                
                // Remove cacti in explosion radius
                this.removeCactiInRadius(centerX, centerY, this.explosionRadius);
            }
            
            removeCactiInRadius(centerX, centerY, radius) {
                const initialCount = this.cacti.length;
                
                this.cacti = this.cacti.filter(cactus => {
                    const distance = Math.sqrt((cactus.x - centerX) ** 2 + (cactus.y - centerY) ** 2);
                    return distance > radius;
                });
                
                const removedCount = initialCount - this.cacti.length;
                if (removedCount > 0) {
                    console.log(`üåµ Removed ${removedCount} cacti from explosion`);
                }
            }
            
            updateClouds() {
                // Spawn new clouds
                if (Math.random() < 0.015) { // Increased spawn rate
                    this.spawnCloud();
                }
                
                // Move and remove off-screen clouds
                this.clouds = this.clouds.filter(cloud => {
                    cloud.x -= this.scrollSpeed * this.pixelScale * 0.5; // Slower than terrain
                    return cloud.x > -cloud.width;
                });
            }
            
            spawnCloud() {
                const cloudWidth = 40;
                const cloudHeight = 20;
                const maxY = this.topSpaceHeight - cloudHeight - 10; // Allow lower positioning
                
                this.clouds.push({
                    x: this.canvasWidth + cloudWidth,
                    y: Math.random() * maxY + 10, // Can be lower now
                    width: cloudWidth,
                    height: cloudHeight,
                    opacity: 0.4 + Math.random() * 0.2 // 0.4-0.6 opacity range
                });
            }
            
            updateScore() {
                this.score = Math.floor(this.worldOffset / this.pixelScale);
                this.scoreDisplay.textContent = this.score.toString().padStart(5, '0');
            }
            
            checkCollisions() {
                if (this.isGameOver) return;
                
                // Get dino bounding boxes
                const dinoBounds = this.getDinoBounds();
                
                // Check cactus collisions
                for (const cactus of this.cacti) {
                    for (const dinoBox of dinoBounds) {
                        if (this.checkAABBCollision(dinoBox, cactus)) {
                            this.gameOver();
                            return;
                        }
                    }
                }
            }
            
            getDinoBounds() {
                const dinoPixelX = this.dinoX * this.pixelScale;
                const dinoGameY = this.gameAreaHeight - (this.dinoY + 24) * this.pixelScale + this.topSpaceHeight;
                
                const horizontalPadding = 6;
                const verticalPaddingTop = 6;
                const verticalPaddingBottom = 8; // Made bottom padding 2 pixels higher
                const totalWidth = 20;
                const headHeight = 8;
                const bodyHeight = 16 - verticalPaddingBottom;
                
                const headRightShift = 2;
                const bodyLeftShift = 2;
                
                const headBox = {
                    x: dinoPixelX + horizontalPadding + headRightShift,
                    y: dinoGameY + verticalPaddingTop,
                    width: totalWidth,
                    height: headHeight,
                    type: 'dino-head'
                };
                
                const bodyBox = {
                    x: dinoPixelX + horizontalPadding - bodyLeftShift,
                    y: dinoGameY + verticalPaddingTop + headHeight,
                    width: totalWidth,
                    height: bodyHeight,
                    type: 'dino-body'
                };
                
                return [headBox, bodyBox];
            }
            
            checkAABBCollision(box1, box2) {
                return box1.x < box2.x + box2.width &&
                       box1.x + box1.width > box2.x &&
                       box1.y < box2.y + box2.height &&
                       box1.y + box1.height > box2.y;
            }
            
            gameOver() {
                this.isGameOver = true;
                this.gameState = 'GAME_OVER';
                this.gameTitle.classList.remove('hidden');
                this.gameTitle.textContent = 'Press <space> to restart';
                
                console.log('üíÄ Game Over!');
            }
            
            // Terrain generation methods
            async updateGeneration() {
                if (!this.session) return;
                
                try {
                    const inputTensor = new ort.Tensor('float32', this.terrain, [1, this.modelHeight, this.modelWidth, 4]);
                    const results = await this.session.run({ input: inputTensor });
                    this.terrain = results.output.data;
                    
                    this.detectCacti();
                    this.renderTerrain();
                } catch (error) {
                    console.error('Generation error:', error);
                }
            }
            
            extendTerrain() {
                // Shift terrain left by one pixel
                for (let y = 0; y < this.modelHeight; y++) {
                    for (let x = 0; x < this.modelWidth - 1; x++) {
                        const sourceIdx = (y * this.modelWidth + (x + 1)) * 4;
                        const targetIdx = (y * this.modelWidth + x) * 4;
                        
                        this.terrain[targetIdx] = this.terrain[sourceIdx];
                        this.terrain[targetIdx + 1] = this.terrain[sourceIdx + 1];
                        this.terrain[targetIdx + 2] = this.terrain[sourceIdx + 2];
                        this.terrain[targetIdx + 3] = this.terrain[sourceIdx + 3];
                    }
                }
                
                // Generate new rightmost column
                this.generateNewColumn(this.modelWidth - 1);
                this.updateCactiPositions();
                this.detectCacti();
                this.renderTerrain();
            }
            
            generateNewColumn(x) {
                // Check if this world position was destroyed
                for (let y = 0; y < this.modelHeight; y++) {
                    const worldX = this.windowStartX + x;
                    const wasDestroyed = this.destroyedAreas.has(`${worldX},${y}`);
                    
                    if (wasDestroyed) {
                        // Keep as empty/destroyed
                        const idx = (y * this.modelWidth + x) * 4;
                        this.terrain[idx] = 0;
                        this.terrain[idx + 1] = 0;
                        this.terrain[idx + 2] = 0;
                        this.terrain[idx + 3] = 0;
                    } else {
                        // Use NCA generation result or set ground
                        if (y === this.modelHeight - 1) {
                            const idx = (y * this.modelWidth + x) * 4;
                            this.terrain[idx] = 0;
                            this.terrain[idx + 1] = 1;
                            this.terrain[idx + 2] = 0;
                            this.terrain[idx + 3] = 1;
                        }
                    }
                }
            }
            
            findRightmostPixel() {
                for (let x = this.modelWidth - 1; x >= 0; x--) {
                    for (let y = 0; y < this.modelHeight; y++) {
                        const idx = (y * this.modelWidth + x) * 4;
                        const alpha = this.terrain[idx + 3];
                        if (alpha > 0.1) {
                            return x;
                        }
                    }
                }
                return 0;
            }
            
            detectCacti() {
                const minY = 12;
                const maxY = 25;
                const minCactusPixels = 10;
                
                const rightEdge = this.findRightmostPixel();
                const searchStart = Math.max(0, rightEdge - 20);
                
                for (let x = searchStart; x < this.modelWidth; x++) {
                    let cactusPixels = 0;
                    
                    for (let y = minY; y < maxY; y++) {
                        const idx = (y * this.modelWidth + x) * 4;
                        const alpha = this.terrain[idx + 3];
                        if (alpha > 0.1) {
                            cactusPixels++;
                        }
                    }
                    
                    if (cactusPixels >= minCactusPixels) {
                        const worldX = this.windowStartX + x;
                        
                        const exists = this.cacti.some(c => 
                            Math.abs(c.worldX - worldX) < 3 && Math.abs(c.x - x) < 3
                        );
                        
                        if (!exists) {
                            this.cacti.push({
                                x: x,
                                y: 0,
                                width: 3,
                                height: 25,
                                worldX: worldX
                            });
                        }
                    }
                }
            }
            
            updateCactiPositions() {
                this.cacti.forEach(cactus => {
                    cactus.x = cactus.worldX - this.windowStartX;
                });
                
                this.cacti = this.cacti.filter(cactus => cactus.x > -10 && cactus.x < this.modelWidth + 10);
            }
            
            renderTerrain() {
                const imageData = this.ctx.createImageData(this.modelWidth, this.modelHeight);
                const data = imageData.data;
                
                for (let i = 0; i < this.terrain.length; i += 4) {
                    const pixelIndex = i;
                    data[pixelIndex] = Math.floor(this.terrain[i] * 255);     // R
                    data[pixelIndex + 1] = Math.floor(this.terrain[i + 1] * 255); // G
                    data[pixelIndex + 2] = Math.floor(this.terrain[i + 2] * 255); // B
                    data[pixelIndex + 3] = Math.floor(this.terrain[i + 3] * 255); // A
                }
                
                this.ctx.putImageData(imageData, 0, this.topSpaceHeight / this.pixelScale);
                this.ctx.imageSmoothingEnabled = false;
                this.ctx.scale(this.pixelScale, this.pixelScale);
                this.ctx.drawImage(this.canvas, 0, this.topSpaceHeight / this.pixelScale);
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            }
            
            render() {
                // Clear canvases
                this.ctx.fillStyle = 'white';
                this.ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);
                
                this.overlayCtx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
                
                // Render terrain
                this.ctx.imageSmoothingEnabled = false;
                this.ctx.drawImage(this.canvas, 0, this.topSpaceHeight, this.canvasWidth, this.gameAreaHeight);
                
                // Render clouds
                this.renderClouds();
                
                // Render dino
                this.renderDino();
                
                // Render bombs
                this.renderBombs();
                
                // Render debug elements
                if (this.showDebugBoxes) {
                    this.renderDebugBoxes();
                }
                
                // Render game over screen
                if (this.isGameOver) {
                    this.renderGameOver();
                }
            }
            
            renderClouds() {
                if (this.cloudImage.complete) {
                    const naturalAspectRatio = this.cloudImage.height / this.cloudImage.width;
                    
                    this.clouds.forEach(cloud => {
                        this.ctx.save();
                        this.ctx.globalAlpha = cloud.opacity;
                        this.ctx.drawImage(
                            this.cloudImage,
                            cloud.x, cloud.y,
                            cloud.width, cloud.width * naturalAspectRatio
                        );
                        this.ctx.restore();
                    });
                }
            }
            
            renderDino() {
                if (this.gameState === 'INTRO') return; // Don't show dino during intro
                
                const dinoPixelX = this.dinoX * this.pixelScale;
                const dinoPixelY = this.gameAreaHeight - (this.dinoY + 24) * this.pixelScale + this.topSpaceHeight;
                
                let dinoSprite = this.assets['DinoStart'];
                
                if (this.isGameOver) {
                    dinoSprite = this.assets['DinoDead'];
                } else if (!this.dinoGrounded) {
                    dinoSprite = this.assets['DinoJump'];
                } else if (this.gameState === 'PLAYING') {
                    const animCycle = Math.floor(this.dinoAnimFrame / this.dinoAnimSpeed) % 2;
                    dinoSprite = animCycle === 0 ? this.assets['DinoRun1'] : this.assets['DinoRun2'];
                }
                
                if (dinoSprite) {
                    this.overlayCtx.drawImage(dinoSprite, dinoPixelX, dinoPixelY, 32, 32);
                }
            }
            
            renderBombs() {
                this.overlayCtx.fillStyle = '#ff4444';
                this.bombs.forEach(bomb => {
                    if (bomb.active) {
                        const bombPixelX = bomb.x * this.pixelScale;
                        const bombPixelY = this.gameAreaHeight - (bomb.y + 2) * this.pixelScale + this.topSpaceHeight;
                        this.overlayCtx.fillRect(bombPixelX, bombPixelY, 6, 6);
                    }
                });
            }
            
            renderDebugBoxes() {
                // Render dino bounding boxes
                const dinoBounds = this.getDinoBounds();
                dinoBounds.forEach((box, index) => {
                    this.overlayCtx.strokeStyle = index === 0 ? '#ff0000' : '#00ff00';
                    this.overlayCtx.lineWidth = 2;
                    this.overlayCtx.strokeRect(box.x, box.y, box.width, box.height);
                });
                
                // Render cactus bounding boxes
                this.overlayCtx.strokeStyle = '#0000ff';
                this.overlayCtx.lineWidth = 1;
                this.cacti.forEach(cactus => {
                    if (cactus.x >= -5 && cactus.x <= this.modelWidth + 5) {
                        const cactusPixelX = cactus.x * this.pixelScale;
                        const cactusPixelY = this.gameAreaHeight - (cactus.y + cactus.height) * this.pixelScale + this.topSpaceHeight + 11;
                        this.overlayCtx.strokeRect(
                            cactusPixelX,
                            cactusPixelY,
                            cactus.width * this.pixelScale,
                            cactus.height * this.pixelScale
                        );
                    }
                });
            }
            
            renderGameOver() {
                if (this.assets['GameOver']) {
                    const gameOverWidth = 192;
                    const gameOverHeight = 14;
                    const x = (this.canvasWidth - gameOverWidth) / 2;
                    const y = this.topSpaceHeight + 50;
                    
                    this.overlayCtx.drawImage(this.assets['GameOver'], x, y, gameOverWidth, gameOverHeight);
                }
            }
            
            createGenerationMarker() {
                const marker = document.createElement('div');
                marker.style.position = 'absolute';
                marker.style.left = `${this.targetGenerationX * this.pixelScale}px`;
                marker.style.top = `${this.topSpaceHeight}px`;
                marker.style.width = '2px';
                marker.style.height = `${this.gameAreaHeight}px`;
                marker.style.backgroundColor = 'red';
                marker.style.zIndex = '999';
                marker.style.pointerEvents = 'none';
                marker.style.display = 'none'; // Hidden by default
                document.querySelector('.game-wrapper').appendChild(marker);
                return marker;
            }
            
            toggleDebugBoxes() {
                this.showDebugBoxes = !this.showDebugBoxes;
                const button = document.getElementById('debugBtn');
                button.textContent = this.showDebugBoxes ? 'üêõ Hide Debug Boxes' : 'üêõ Show Debug Boxes';
                
                // Show/hide generation marker with debug boxes
                this.generationMarker.style.display = this.showDebugBoxes ? 'block' : 'none';
                
                console.log(`üêõ Debug boxes ${this.showDebugBoxes ? 'enabled' : 'disabled'}`);
            }
            
            start() {
                const gameLoop = () => {
                    this.update();
                    requestAnimationFrame(gameLoop);
                };
                gameLoop();
            }
        }
        
        // Initialize game
        window.addEventListener('load', () => {
            const game = new NCADinoGame();
            game.start();
        });
    </script>
</body>
</html>